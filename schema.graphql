type Dao @entity {
  id: ID!
  version: String
  summoner: Bytes!
  newContract: String
  deleted: Boolean
  summoningTime: BigInt!
  createdAt: String!
  periodDuration: BigInt!
  votingPeriodLength: BigInt!
  gracePeriodLength: BigInt!
  proposalDeposit: BigInt!
  dilutionBound: BigInt!
  processingReward: BigInt!
  guildBankAddress: Bytes
  guildBankBalanceV1: BigInt
  totalShares: BigInt!
  totalLoot: BigInt!
  v22Setup: Boolean
  spamPreventionAddress: Bytes
  spamPreventionAmount: BigInt
}


type MemberUri @entity {
  id: ID!
  members: [Member!] @derivedFrom(field: "dao")
}


type Member @entity {
  id: ID!
  createdAt: String!
  dao: MemberUri!
  memberAddress: Bytes!
  delegateKey: Bytes!
  shares: BigInt!
  loot: BigInt!
  exists: Boolean!
  tokenTribute: BigInt!
  didRagequit: Boolean!
  proposedToKick: Boolean
  kicked: Boolean
  jailed: BigInt
}

# type Vote @entity {
#   id: ID!
#   createdAt: String!
#   proposal: Proposal!
#   member: Member!
#   uintVote: Int!
#   molochAddress: Bytes!
#   memberAddress: Bytes
#   memberPower: BigInt
#   proposalIndex: BigInt
#   delegateKey: Bytes
# }
# 
# type Proposal @entity {
#   id: ID!
#   createdAt: String!
#   createdBy: Bytes!
#   proposalIndex: BigInt
#   proposalId: BigInt!
#   moloch: Moloch!
#   molochAddress: Bytes!
#   member: Member!
#   memberAddress: Bytes!
#   delegateKey: Bytes!
#   applicant: Bytes!
#   proposer: Bytes
#   sponsor: Bytes!
#   processor: Bytes
#   sharesRequested: BigInt!
#   lootRequested: BigInt!
#   tributeOffered: BigInt!
#   tributeToken: Bytes!
#   tributeTokenSymbol: String
#   tributeTokenDecimals: BigInt
#   paymentRequested: BigInt!
#   paymentToken: Bytes!
#   paymentTokenSymbol: String
#   paymentTokenDecimals: BigInt
#   startingPeriod: BigInt
#   yesVotes: BigInt!
#   noVotes: BigInt!
#   sponsored: Boolean!
#   sponsoredAt: String
#   processed: Boolean!
#   processedAt: String
#   didPass: Boolean!
#   cancelled: Boolean
#   cancelledAt: String
#   aborted: Boolean
#   whitelist: Boolean
#   guildkick: Boolean
#   newMember: Boolean
#   trade: Boolean
#   guildkickOrWhitelistOrMinion: Boolean
#   details: String
#   maxTotalSharesAndLootAtYesVote: BigInt
#   votes: [Vote!] @derivedFrom(field: "proposal")
#   yesShares: BigInt!
#   noShares: BigInt!
#   votingPeriodStarts: BigInt!
#   votingPeriodEnds: BigInt!
#   gracePeriodEnds: BigInt!
#   molochVersion: String!
#   isMinion: Boolean!
#   uberHausMinionExecuted: Boolean
#   executed: Boolean
#   minionAddress: Bytes
#   minionExecuteActionTx: MolochTransaction
#   minion: Minion
#   escrow: ProposalEscrow @derivedFrom(field: "proposal")
#   actions: [MinionAction!] @derivedFrom(field: "proposal")
# }
# 
# type RageQuit @entity {
#   id: ID!
#   createdAt: String!
#   moloch: Moloch!
#   molochAddress: Bytes!
#   member: Member!
#   memberAddress: Bytes!
#   shares: BigInt!
#   loot: BigInt!
# }
# 
# type DaoMeta @entity {
#   id: ID!
#   title: String
#   version: String
#   newContract: String
#   http: String
# }
# 
# type Minion @entity {
#   id: ID!
#   createdAt: String!
#   minionAddress: Bytes!
#   molochAddress: Bytes!
#   moloch: Moloch!
#   details: String!
#   minionType: String!
#   proposals: [Proposal!] @derivedFrom(field: "minion")
#   uberHausAddress: Bytes
#   uberHaus: Moloch
#   uberHausDelegateRewardFactor: BigInt
#   uberHausDelegate: Bytes
#   safeAddress: Bytes
#   safeMinionVersion: String
#   crossChainMinion: Boolean!
#   foreignChainId: String
#   foreignSafeAddress: Bytes
#   bridgeModule: String
#   version: String
#   minQuorum: BigInt
#   streams: [MinionStream!] @derivedFrom(field: "minion")
# }
# 
# type MinionStream @entity {
#   id: ID!
#   proposalId: String!
#   createdAt: String!
#   to: Bytes!
#   tokenAddress: Bytes!
#   superTokenAddress: Bytes!
#   rate: BigInt!
#   minDeposit: BigInt!
#   proposer: Bytes!
#   executed: Boolean!
#   executedBlock: BigInt
#   executedAt: String
#   execTxHash: Bytes
#   active: Boolean!
#   ctx: Bytes!
#   canceledAt: String
#   canceledBy: Bytes
#   minion: Minion!
# }
# 
# type SafeMinion @entity {
#   id: ID!
#   minions: [Minion!]!
# }
# 
# type MolochTransaction @entity {
#   id: ID!
#   createdAt: String!
# }
# 
# type ProposalEscrow @entity {
#   id: ID!
#   proposal: Proposal!
#   minionAddress: Bytes!
#   molochAddress: Bytes!
#   proposer: Bytes!
#   tokenAddresses: [Bytes!]
#   tokenTypes: [BigInt!]
#   tokenIds: [BigInt!]
#   amounts: [BigInt!]
# }
# 
# type MinionAction @entity {
#   id: ID!
#   proposal: Proposal!
#   minionAddress: Bytes!
#   molochAddress: Bytes!
#   target: Bytes!
#   withdrawToken: Bytes!
#   withdrawValue: BigInt!
#   data: String!
#   memberOnly: Boolean!
#   index: BigInt!
# }
# 
# type Shaman @entity {
#   id: ID!
#   createdAt: String!
#   shamanAddress: Bytes!
#   molochAddress: Bytes!
#   moloch: Moloch!
#   enabled: Boolean!
# }
# 
# type Content @entity {
#   id: ID!
#   createdAt: String!
#   transactionHash: Bytes!
#   molochAddress: String
#   moloch: Moloch
#   memberAddress: Bytes!
#   content: String!
#   contentType: String!
#   location: String!
#   title: String
#   description: String
#   ratified: Boolean!
#   rawData: String!
# }
